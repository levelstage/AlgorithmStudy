상태는 시간이랑 내 위치밖에 없음
근데 일단 시간으로는 DP를 사용할 수 없음.
O(N)으로는 시간초과가 날 수 밖에 없으므로 어지간하면 거의 계산으로 풀수밖에 없을것같은데

a[i] = b[i-1] + c[i-1];
b[i] = a[i-1] + c[i-1] + d[i-1];
c[i] = a[i-1] + b[i-1] + d[i-1] + e[i-1];
d[i] = b[i-1] + c[i-1] + e[i-1] + f[i-1];
e[i] = c[i-1] + d[i-1] + f[i-1] + h[i-1];
f[i] = d[i-1] + e[i-1] + g[i-1];
g[i] = f[i-1] + h[i-1];
h[i] = e[i-1] + g[i-1];

a[i] = (a[i-2] + c[i-2] + d[i-2]) + (a[i-2] + b[i-2] + d[i-2] + e[i-2]);
     = {(b[i-3] + c[i-3]) + (a[i-3] + b[i-3] + d[i-3] + e[i-3]) + (b[i-3] + c[i-3] + e[i-3] + f[i-3])} + {...}

이런 식으로 점화식이 발산하게 되는데, 아마 N이 10억 이상만 아니었어도 이렇게 DP로 풀 수 있었을 것이다.
근데 N이 10억이라 디피가 안되네???

그니까 핵심은 지점 A에서 지점 B로 가는데에 시간이 K라면 그 경우의 수는 정해져 있으며,
분할이 가능하다는 것. 이걸 이용해야 할거같은데
50억, 25억, 12.5억 이런식으로 반으로 줄여나가면서 문제를 해결하고싶은데
근데 이게 문제가 뭐냐면 지점이 8개나 된다는 거. 지점이 8개라서 경우의 수를 반으로 줄이면 8배씩 처리가 늘어남;;
아닌가? 괜찮나? 어? 괜찮을지도 모르겟는데?
DP를 섞으면... 어차피 log N은 30정도고 from, to 하면 8개니까
근데 정확히 반으로 안갈리는 경우가 있잖아. d가 홀수면 뭐 어떻게할래?
ㅠㅠ
아잇%%^%^&
근데 반으로 잘라도 어차피 1차이면
그정도는 극복 가능하다 아님?

그러면 예를 들어서
2n+1이야 d가 그러면
A부터 C까지 n으로 가는 경우의 수 * A부터 C까지 n+1로 가는 경우의 수를 걍 구하면 되고, 이러면 DT크기도 두배밖에 안늘어남.

일단 dt설계를 dt[출발][도착][시간(2^n 기준)][2로나눈 나머지]

A~C 까지의 경로의 수는
A~B까지의 경로의 수 곱하기 B~C까지의 경로의 수

예를 들어 25면
13 과 12로 나눔
어차피 둘다 나누면 6이 된다. 어? 근데 23이면?
11과 12로 나누는데 이러면 11은 나누면 5고 12는 6인데? ㅅㅂ비상
규격을 맞추고 싶은데...
92이면
46
23 
11 11+1
5 5+1
2 2+1
1 1
이렇게 풀자
그러면
f(a, b, d) = 시그마{f(a, i, d/2) * f(i, b, d/2)}; (d가 짝수일때)
           = 시그마{f(a, i, d/2) * 시그마{f(i, j, d/2) * path[j][b]}} (d가 홀수일때)

